% Pandoc -- Document Structure
% Sébastien Boisgérault
% January 13, 2016

**TODO:** explain that the "spec" of the document structure

Goals / the take-away:

  - If you intend to parse the JSON output from pandoc -- outside of Haskell, 
    say in Javascript, Python, etc. -- 
    you will thank me.

  - If you want to use the current tools to do stuff with pandoc documents
    in dynamic languages (yeah, I am looking at you `pandoc-filters`),
    think again.

  - High-level: prepare for a Python lib to instantiate, analyze, transform, etc.
    documents that are instance of the Pandoc Document Model into Pythonic type. 
    Prerequisite:understand this model (Doh'!) which means a bit of Haskell 
    typing, and understand how these instances are mapped to the generic JSON
    model.

  - Help you understand the doc (in Haskell) of Pandoc Types, to understand
    the Pandoc "Document Model". To this, we need to learn a bit about the
    Haskell types.

  - Understand how AESON converts such Haskell objects into JSON.

  - Understand how you can (or cannot) use the JSON output in your favorite
    langage (on the limitation side, make pandoc-filters fail?)

  - See that parsing this is difficult, UNLESS YOU HAVE A REPRESENTATION OF
    THE PANDOC TYPE HIERARCHY IN THE PARSER.

  - Type-Aware Parsing, what it is why it is necessary: a translator from the
    JSON representation to the Haskell representation (or a Python typed
    representation) needs to know about the type hierarchy, otherwise document
    fragments are ambiguous **in the current JSON representation** (example?
    even when it is not strictly ambiguous, the differentiation may be a mess).

  - Understand the JSON representation of Pandoc document: for this, you need
    to understand a bit of the Haskell type system and how AESON deals with it.

TODO:


  - LONG-TERM: What we intend to do: go beyond the JSON representation in Python,
    leverage a typed representation that is more natural ("Pythonic"),
    more familiar and convenient for Python developers. THIS is the
    primary goal of the Python module `pandoc`, not being a wrapper
    around the Haskell program. --> GET THIS COMMENT OUT OF THIS DOC.

  - replicate the steps to be able to test some serialization in Pandoc.
    From the command-line or ghci?

  - explain the Haskell constructs of the type hierarchy so that
    the users can understand the Haskell doc.

  - explain JSON serialization of each construct.

  - extra limitation when we have not the type hierarchy even with primitive
    types: tuples are serialized as lists.


Preamble -- The Haskell Interactive Environment
================================================================================

I actually find easier to explore the pandoc document model from the Haskell
interactive environment than from the command line -- 
even though I am not really familiar with Haskell. 
This approach doesn't require pandoc the command-line tool, but the associated 
Haskell packages; they may not be available if you have only performed a
basic install of pandoc.

Make sure that the Haskell interactive environement [GHCi] and all Haskell 
packages associated to pandoc are installed. On Ubuntu for example,
you may execute the command 

    $ sudo apt-get install libghc-pandoc.*

and then start GHCi with 

    $ ghci

In this document, we denote commands executed in GHCi with the `>` prefix; 
that's a behavior that you can reproduce if you type 

    :set prompt "> "

once you have started GHCi.

[GHCi]: https://wiki.haskell.org/GHC/GHCi


Pandoc Types
================================================================================

As of today, the best way to understand the details of the pandoc document model
is to refer to the documentation of the `pandoc-types` Haskell package, 
more precisely of its `Text.Pandoc.Definition` module.
This module contains the definition of all pandoc types used to describe
any Pandoc document; you may search for `pandoc-types` on the [Hackage] 
package archive to read the latest version of the documentation 
(1.16 at the moment).

[Hackage]: http://hackage.haskell.org

The bad news I guess is that you have to understand the basic of Haskell types
to understand the document model; on the flip side, this documentation is
very precise and quite simple once you understand the basic constructs.

We are going to explain the basics of Haskell data types directly on
the types provided with Pandoc; more details may be found on the
[Haskell Wiki](https://wiki.haskell.org/Type).

We can get all the information wen need about pandoc types we need from GHCi. 
First, load the `Text.Pandoc.Definition` module

    > import Text.Pandoc.Definition

Then, say that you are interested in the definition of the type `Pandoc` 
that is associated to whole documents; type:

    > :info Pandoc
    data Pandoc = Pandoc Meta [Block]
    ...

(the ellipsis denotes details of the output that we have omitted).
The first line of the output specifies that the type `Pandoc` (keyword`data`) 
is declared with a single constructor (in the right-hand side), named `Pandoc`, 
whose arguments are an instance of `Meta` -- the document metadata -- 
and a list of `Block` instances -- that compose the document itself.

This is the enough information to build an instance of document: 
`Text.Pandoc.Definition` already provides an empty metadata with `nullMeta`,
so we may use this

    > let meta = nullMeta
    > meta
    Meta {unMeta = fromList []}

(don't freak out, we are going to explain this weird output syntax in a moment)
and for blocks, the easiest thing to do is to use an empty list:

    > let blocks = []
    > blocks
    []

Now, we may assemble these arguments to create an (empty) document:

    > let doc = Pandoc meta blocks
    > doc
    Pandoc (Meta {unMeta = fromList []}) []

You may repeat this approach with the types that used to define `Pandoc`
instances. For example, if you want to know more about the contents of blocks, 
type:

    > :info Block
    data Block
      = Plain [Inline]
      | Para [Inline]
      | CodeBlock Attr String
      | RawBlock Format String
      | BlockQuote [Block]
      | OrderedList ListAttributes [[Block]]
      | BulletList [[Block]]
      | DefinitionList [([Inline], [[Block]])]
      | Header Int Attr [Inline]
      | HorizontalRule
      | Table [Inline] [Alignment] [Double] [TableCell] [[TableCell]]
      | Div Attr [Block]
      | Null
    ...

The `Block` type has 13 different constructors. 
Some of the constructors have no arguments, for example the horizontal rule

    > let block = HorizontalRule

but most of them have arguments of various types. 
`Attr`, `Format`, `ListAttributes`, etc. are types defined by pandoc,
but `String` and `Int` are Haskell primitive types. The notation `[]` refers to 
lists and `()` refers to tuples, so `[[Block]]` is for example a list of list 
of blocks and `[([Inline], [[Block]])]` is a list of pairs of list of inlines 
and list of list of blocks (ouch !).

Some of the pandoc types are not really new constructs but only aliases used
to provide a shorter notation. For example, `Attr` is one of such types,
defined with the `type` keyword:

    > :info Attr
    type Attr = (String, [String], [(String, String)])

Hence we may define a code block with

    > let attr = ("", [], [])
    > let block = CodeBlock attr "content"

The declaration of the `Format` type doesn't use the `data` keyword either, 
but instead the `newtype` keyword

    > :info Format
    newtype Format = Format String
    ...

You can think of it as an optimization of the `data` construct when 
the type has a simple constructor whose name is the type name, so the
instantiation is business as usual:

    > let format = Format "html"

The final construct that we need to explain is the record. Consider for
example the `Meta` type:

    > :info Meta
    newtype Meta
      = Meta {unMeta :: Data.Base.Map String MetaValue}

Its only constructor is declared as a record -- with the `{}` syntax -- 
that has a single field named `unMeta`. As a consequence, it can be 
instantiated with named arguments instead of positional argument:

    > import Data.Map (empty, fromList, Map)
    > let meta = Meta {unMeta = empty}
    > meta
    Meta {unMeta = fromList []}

An extra feature of this declaration: a function `unMeta` has been automatically
defined to get the content of the `unMeta` field from the instance of `Meta`:
    
    > unMeta meta
    fromList []

Note however that records keep the behavior of classic constructors and that
`meta` could have been defined with the positional argument syntax:

    > let meta = Meta (empty)
    > meta
    Meta {unMeta = fromList []}

The only other record used by pandoc types is `Citation`:

    > :info Citation
    data Citation
      = Citation {citationId :: String,
                  citationPrefix :: [Inline],
                  citationSuffix :: [Inline],
                  citationMode :: CitationMode,
                  citationNoteNum :: Int,
                  citationHash :: Int}
    ...

After `Pandoc`, `Block` and `Meta`, it's a good idea to have a look
at the `Inline` pandoc type, the last major component of the document model.

    > :info Inline
    data Inline
      = Str String
      | Emph [Inline]
      | Strong [Inline]
      | Strikeout [Inline]
      | Superscript [Inline]
      | Subscript [Inline]
      | SmallCaps [Inline]
      | Quoted QuoteType [Inline]
      | Cite [Citation] [Inline]
      | Code Attr String
      | Space
      | LineBreak
      | Math MathType String
      | RawInline Format String
      | Link [Inline] Target
      | Image [Inline] Target
      | Note [Block]
      | Span Attr [Inline]
    ...

There is no new Haskell type construct here, everything should be clear.


Appendix -- Pandoc Types Definition
================================================================================

To display the complete list of pandoc types definition, type in GHCi:

    > import Data.Map (Map)
    > import Text.Pandoc.Definition
    > :browse

The output of this command sequence, slightly reformated to enhance readability:

    data Alignment
      = AlignLeft 
      | AlignRight 
      | AlignCenter 
      | AlignDefault

    type Attr 
      = (String, [String], [(String, String)])

    data Block
      = Plain [Inline]
      | Para [Inline]
      | CodeBlock Attr String
      | RawBlock Format String
      | BlockQuote [Block]
      | OrderedList ListAttributes [[Block]]
      | BulletList [[Block]]
      | DefinitionList [([Inline], [[Block]])]
      | Header Int Attr [Inline]
      | HorizontalRule
      | Table [Inline] [Alignment] [Double] [TableCell] [[TableCell]]
      | Div Attr [Block]
      | Null

    data Citation
      = Citation {citationId :: String,
                  citationPrefix :: [Inline],
                  citationSuffix :: [Inline],
                  citationMode :: CitationMode,
                  citationNoteNum :: Int,
                  citationHash :: Int}

    data CitationMode 
      = AuthorInText 
      | SuppressAuthor 
      | NormalCitation

    newtype Format 
      = Format String

    data Inline
      = Str String
      | Emph [Inline]
      | Strong [Inline]
      | Strikeout [Inline]
      | Superscript [Inline]
      | Subscript [Inline]
      | SmallCaps [Inline]
      | Quoted QuoteType [Inline]
      | Cite [Citation] [Inline]
      | Code Attr String
      | Space
      | LineBreak
      | Math MathType String
      | RawInline Format String
      | Link [Inline] Target
      | Image [Inline] Target
      | Note [Block]
      | Span Attr [Inline]

    type ListAttributes 
      = (Int, ListNumberStyle, ListNumberDelim)

    data ListNumberDelim 
      = DefaultDelim 
      | Period 
      | OneParen 
      | TwoParens

    data ListNumberStyle
      = DefaultStyle
      | Example
      | Decimal
      | LowerRoman
      | UpperRoman
      | LowerAlpha
      | UpperAlpha

    data MathType
      = DisplayMath 
      | InlineMath

    newtype Meta
      = Meta {unMeta :: Map String MetaValue}

    data MetaValue
      = MetaMap (Map String MetaValue)
      | MetaList [MetaValue]
      | MetaBool Bool
      | MetaString String
      | MetaInlines [Inline]
      | MetaBlocks [Block]

    data Pandoc 
      = Pandoc Meta [Block]

    data QuoteType 
      = SingleQuote 
      | DoubleQuote

    type TableCell 
      = [Block]

    type Target 
      = (String, String)

    ...

Function declarations have been omitted.



