% The Pandoc Document Model
% Sébastien Boisgérault
% January 13, 2016

Goals:

  - High-level: prepare for a Python lib to instantiate, analyze, transform, etc.
    documents that are instance of the Pandoc Document Model into Pythonic type. 
    Prerequisite:understand this model (Doh'!) which means a bit of Haskell 
    typing, and understand how these instances are mapped to the generic JSON
    model.

  - Help you understand the doc (in Haskell) of Pandoc Types, to understand
    the Pandoc "Document Model". To this, we need to learn a bit about the
    Haskell types.

  - Understand how AESON converts such Haskell objects into JSON.

  - Understand how you can (or cannot) use the JSON output in your favorite
    langage (on the limitation side, make pandoc-filters fail?)

  - See that parsing this is difficult, UNLESS YOU HAVE A REPRESENTATION OF
    THE PANDOC TYPE HIERARCHY IN THE PARSER.

  - Type-Aware Parsing, what it is why it is necessary: a translator from the
    JSON representation to the Haskell representation (or a Python typed
    representation) needs to know about the type hierarchy, otherwise document
    fragments are ambiguous **in the current JSON representation** (example?
    even when it is not strictly ambiguous, the differentiation may be a mess).

  - Understand the JSON representation of Pandoc document: for this, you need
    to understand a bit of the Haskell type system and how AESON deals with it.

TODO:


  - LONG-TERM: What we intend to do: go beyond the JSON representation in Python,
    leverage a typed representation that is more natural ("Pythonic"),
    more familiar and convenient for Python developers. THIS is the
    primary goal of the Python module `pandoc`, not being a wrapper
    around the Haskell program. --> GET THIS COMMENT OUT OF THIS DOC.

  - replicate the steps to be able to test some serialization in Pandoc.
    From the command-line or ghci?

  - explain the Haskell constructs of the type hierarchy so that
    the users can understand the Haskell doc.

  - explain JSON serialization of each construct.

  - extra limitation when we have not the type hierarchy even with primitive
    types: tuples are serialized as lists.


Preamble -- The Haskell Interactive Environment
================================================================================

I actually find easier to explore the pandoc document model from the Haskell
interactive environment than from the command line -- 
even though I am not really familiar with Haskell. 
This approach doesn't require pandoc the command-line tool, but the associated 
Haskell packages; they may not be available if you have only performed a
basic install of pandoc.

Make sure that the Haskell interactive environement [GHCi] and all Haskell 
packages associated to pandoc are installed. On Ubuntu for example,
you may execute the command 

    $ sudo apt-get install libghc-pandoc.*

and then start GHCi with 

    $ ghci

In this document, we denote commands executed in GHCi with the `>` prefix; 
that's a behavior that you can reproduce if you type 

    :set prompt "> "

once you have started GHCi.

[GHCi]: https://wiki.haskell.org/GHC/GHCi


Pandoc Types
================================================================================

As of today, the best way to understand the details of the pandoc document model
is to refer to the documentation of the `pandoc-types` Haskell package, 
more precisely of its `Text.Pandoc.Definition` module.
This module contains the definition of all pandoc types used to describe
any Pandoc document; you may search for `pandoc-types` on the [Hackage] 
package archive to read the latest version of the documentation 
(1.16 at the moment).

[Hackage]: http://hackage.haskell.org

The bad news I guess is that you have to understand the basic of Haskell types
to understand the document model; on the flip side, this documentation is
very precise and quite simple once you understand the basic constructs.

We are going to explain the basics of Haskell data types directly on
the types provided with Pandoc; more details may be found on the
[Haskell Wiki](https://wiki.haskell.org/Type).

We can get all the information wen need about pandoc types we need from GHCi. 
First, load the `Text.Pandoc.Definition` module

    > import Text.Pandoc.Definition

Then, say that you are interested in the definition of the type `Pandoc` 
that is associated to whole documents; type:

    > :info Pandoc
    data Pandoc = Pandoc Meta [Block]
    ...

(the ellipsis denotes details of the output that we have omitted).
The first line of the output specifies that the type `Pandoc` (keyword`data`) 
is declared with a single constructor (in the right-hand side), named `Pandoc`, 
whose arguments are an instance of `Meta` -- the document metadata -- 
and a list of `Block` instances -- that compose the document itself.

This is the enough information to build an instance of document: 
`Text.Pandoc.Definition` already provides an empty metadata with `nullMeta`,
so we may use this

    > let meta = nullMeta
    > meta
    Meta {unMeta = fromList []}

(don't freak out, we are going to explain this weird output syntax in a moment)
and for blocks, the easiest thing to do is to use an empty list:

    > let blocks = []
    > blocks
    []

Now, we may assemble these arguments to create an (empty) document:

    > let doc = Pandoc meta blocks
    > doc
    Pandoc (Meta {unMeta = fromList []}) []

You may repeat this approach with the types that used to define `Pandoc`
instances. For example, if you want to know more about the contents of blocks, 
type:

    > :info Block
    data Block
      = Plain [Inline]
      | Para [Inline]
      | CodeBlock Attr String
      | RawBlock Format String
      | BlockQuote [Block]
      | OrderedList ListAttributes [[Block]]
      | BulletList [[Block]]
      | DefinitionList [([Inline], [[Block]])]
      | Header Int Attr [Inline]
      | HorizontalRule
      | Table [Inline] [Alignment] [Double] [TableCell] [[TableCell]]
      | Div Attr [Block]
      | Null
    ...

The `Block` type has 13 different constructors. 
Some of the constructors have no arguments, for example the horizontal rule

    > let block = HorizontalRule

but most of them have arguments of various types. 
`Attr`, `Format`, `ListAttributes`, etc. are types defined by pandoc,
but `String` and `Int` are Haskell primitive types. The notation `[]` refers to 
lists and `()` refers to tuples, so `[[Block]]` is for example a list of list 
of blocks and `[([Inline], [[Block]])]` is a list of pairs of list of inlines 
and list of list of blocks (ouch !).

Some of the pandoc types are not really new constructs but only aliases used
to provide a shorter notation. For example, `Attr` is one of such types,
defined with the `type` keyword:

    > :info Attr
    type Attr = (String, [String], [(String, String)])

Hence we may define a code block with

    > let attr = ("", [], [])
    > let block = CodeBlock attr "content"

The declaration of the `Format` type doesn't use the `data` keyword either, 
but instead the `newtype` keyword

    > :info Format
    newtype Format = Format String
    ...

You can think of it as an optimization of the `data` construct when 
the type has a simple constructor whose name is the type name, so the
instantiation is business as usual:

    > let format = Format "html"

The final construct that we need to explain is the record. Consider for
example the `Meta` type:

    > :info Meta
    newtype Meta
      = Meta {unMeta :: Data.Base.Map String MetaValue}

Its only constructor is declared as a record -- with the `{}` syntax -- 
that has a single field named `unMeta`. As a consequence, it can be 
instantiated with named arguments instead of positional argument:

    > import Data.Map (empty, fromList, Map)
    > let meta = Meta {unMeta = empty}
    > meta
    Meta {unMeta = fromList []}

An extra feature of this declaration: a function `unMeta` has been automatically
defined to get the content of the `unMeta` field from the instance of `Meta`:
    
    > unMeta meta
    fromList []

Note however that records keep the behavior of classic constructors and that
`meta` could have been defined with the positional argument syntax:

    > let meta = Meta (empty)
    > meta
    Meta {unMeta = fromList []}

The only other record used by pandoc types is `Citation`:

    > :info Citation
    data Citation
      = Citation {citationId :: String,
                  citationPrefix :: [Inline],
                  citationSuffix :: [Inline],
                  citationMode :: CitationMode,
                  citationNoteNum :: Int,
                  citationHash :: Int}
    ...

After `Pandoc`, `Block` and `Meta`, it's a good idea to have a look
at the `Inline` pandoc type, the last major component of the document model.

    > :info Inline
    data Inline
      = Str String
      | Emph [Inline]
      | Strong [Inline]
      | Strikeout [Inline]
      | Superscript [Inline]
      | Subscript [Inline]
      | SmallCaps [Inline]
      | Quoted QuoteType [Inline]
      | Cite [Citation] [Inline]
      | Code Attr String
      | Space
      | LineBreak
      | Math MathType String
      | RawInline Format String
      | Link [Inline] Target
      | Image [Inline] Target
      | Note [Block]
      | Span Attr [Inline]
    ...

There is no new Haskell type construct here, everything should be clear.

JSON Representation
================================================================================

Pandoc leverages the [aeson] package to serialize pandoc type instances as JSON
strings.
With three lines of Haskell we may define a function `js` that displays the JSON
representation of any pandoc construct:

[aeson]: https://hackage.haskell.org/package/aeson

    > import Data.Aeson (encode, ToJSON)
    > import qualified Data.ByteString.Lazy.Char8 as BS
    > let js :: (ToJSON a) => a -> IO (); js = BS.putStrLn . encode

Let's play with this a bit:

    > let doc = Pandoc (nullMeta) []
    > js doc
    [{"unMeta":{}},[]]

**FUCK**, this is insane, one argument is treated differently from 0 or 
many ? Or is it the string type ? Jeezus wept, what a giant mess.

    > let inline = Str "pandoc"
    > js inline
    {"t":"Str","c":"pandoc"}
    > let inline = Space
    > js inline
    {"t":"Space","c":[]}
    > js $ Emph [Str "kkk"]
    {"t":"Emph","c":[{"t":"Str","c":"kkk"}]}

Is it basic aeson behavior or a pandoc configuration ? Aeson stuff, definitively.
Apparently, when a constructor has a single argument, the string wrapper is
dropped

-----

How I learned to hate AESON: JSON exports that is supposed to
be helpful but is not really unless u have kept the type hierarchy (or:
"premature optimization"): stripped types and single-argument unwrapping
optimization.

TODO: fuck pandoc-filters, JSON is not usable unless you also pull the
types definition info.

\newpage



Pythonize this info
--------------------------------------------------------------------------------

  - copy-and-paste the type definition info from ghci into `_types.hs`.

  - invoke 

        $ pandoc/types/defs/main.py _types.hs > _types.py

  - `types.py` now contains a Python description of the type structure,
    into a `defs` global variable.

Hence 

  - `pandoc.types.def` contains info about the Pandoc DOM structure, 
    in a raw form

  - `pandoc.types` declares the Python classes from this structure:
    explain this stuff in the next section ...


Pandoc.Types
--------------------------------------------------------------------------------

Every Haskell data type corresponds to one Python data type defined in
`pandoc.types`. It is either a primitive, a type (for the lack of a better
world), a singleton or a typedef. Every such class is available as a symbol
of the `pandoc.types` module and as a key of the `primitives`, `types`,
`singletons` or `typedefs` dictionary.

  - Primitives are matched directly to Python native types: 
    `String` corresponds to `unicode`, `Bool` to `bool`, etc.

  - Types correspond the Haskell data types declared with the `data` or `newtype` 
    keywords

  - Typedefs are type aliases (or synonyms), introduced in Haskell with the
    `type` keyword.

Source: <https://wiki.haskell.org/Type>

JSON Serialization
================================================================================

Insist on the fact that Pandoc and Aeson conspire to make the JSON output as
minimal as possible.

Need to document/understand how ALL constructs of the Pandoc document model
are serialized. A small helper to display the representation of a document 
fragment would be nice ...

Ref to the doc / source of the Haskell librray.

A word about AESON, the settings used in `Text.Pandoc.Types`, the results:
display examples of the different kind of serialisation used:

  - primitive types: Int, String, etc.

  - lists, maps,

  - algebraic data types

  - newtype stuff (ex: Format)

  - type Target = (String, String),

  - records: Meta, Citation

-----

newtype: Meta, Format, records: Meta, Citation.

examples:

    Meta -> {"unMeta": metadata_map}

No indication in the json of the Meta type, and not a list of arguments but a
map indexed by the (here unique) fields.

    Format -> "html"

The type info has been stripped, and the content directly exposed. Mmmm,
the content is not even in a list? How would have been exposed a newtype
wrapper with multiple args? OK, it CANNOT happen, by construction, 
newtypes have a single field.

    Citation -> {"citationSuffix":...,
                 "citationNoteNum":...,
                 "citationMode":...,
                 "citationPrefix":...,
                 "citationId":...,
                 "citationHash":...}

So basically, records are serialized as dictionaries and their type info is
stripped; newtypes are also stripped type info. That's all there is.

-----

Need to explain of a "JSON parsing" driven by a type hierarchy can work.

THIS is meant to be implemented at the top-level, in `pandoc` main 
(`load` function; a script would also be nice to test this stuff from 
the command-line).

------

AAAAH. The special case about the serialization of Pandoc. Is it because 
there is a single constructor, hence the constructor name is not required?
(when you have access to the type hierarchy). That would make sense.
Test this assumption with custom types. YEAH, THAT'S IT !


Appendix -- Pandoc Types Definition
================================================================================

To display the complete list of pandoc types definition, type in GHCi:

    > import Data.Map (Map)
    > import Text.Pandoc.Definition
    > :browse

The output of this command sequence, slightly reformated to enhance readability:

    data Alignment
      = AlignLeft 
      | AlignRight 
      | AlignCenter 
      | AlignDefault

    type Attr 
      = (String, [String], [(String, String)])

    data Block
      = Plain [Inline]
      | Para [Inline]
      | CodeBlock Attr String
      | RawBlock Format String
      | BlockQuote [Block]
      | OrderedList ListAttributes [[Block]]
      | BulletList [[Block]]
      | DefinitionList [([Inline], [[Block]])]
      | Header Int Attr [Inline]
      | HorizontalRule
      | Table [Inline] [Alignment] [Double] [TableCell] [[TableCell]]
      | Div Attr [Block]
      | Null

    data Citation
      = Citation {citationId :: String,
                  citationPrefix :: [Inline],
                  citationSuffix :: [Inline],
                  citationMode :: CitationMode,
                  citationNoteNum :: Int,
                  citationHash :: Int}

    data CitationMode 
      = AuthorInText 
      | SuppressAuthor 
      | NormalCitation

    newtype Format 
      = Format String

    data Inline
      = Str String
      | Emph [Inline]
      | Strong [Inline]
      | Strikeout [Inline]
      | Superscript [Inline]
      | Subscript [Inline]
      | SmallCaps [Inline]
      | Quoted QuoteType [Inline]
      | Cite [Citation] [Inline]
      | Code Attr String
      | Space
      | LineBreak
      | Math MathType String
      | RawInline Format String
      | Link [Inline] Target
      | Image [Inline] Target
      | Note [Block]
      | Span Attr [Inline]

    type ListAttributes 
      = (Int, ListNumberStyle, ListNumberDelim)

    data ListNumberDelim 
      = DefaultDelim 
      | Period 
      | OneParen 
      | TwoParens

    data ListNumberStyle
      = DefaultStyle
      | Example
      | Decimal
      | LowerRoman
      | UpperRoman
      | LowerAlpha
      | UpperAlpha

    data MathType
      = DisplayMath 
      | InlineMath

    newtype Meta
      = Meta {unMeta :: Map String MetaValue}

    data MetaValue
      = MetaMap (Map String MetaValue)
      | MetaList [MetaValue]
      | MetaBool Bool
      | MetaString String
      | MetaInlines [Inline]
      | MetaBlocks [Block]

    data Pandoc 
      = Pandoc Meta [Block]

    data QuoteType 
      = SingleQuote 
      | DoubleQuote

    type TableCell 
      = [Block]

    type Target 
      = (String, String)

    ...

(function declarations have been omitted).



