% Pandoc Types

  - What we intend to do: go beyond the JSON representation in Python,
    leverage a typed representation that is more natural ("Pythonic"),
    more familiar and convenient for Python developers. THIS is the
    primary goal of the Python module `pandoc`, not being a wrapper
    around the Haskell program.

  - Type-Aware Parsing, what it is why it is necessary: a translator from the
    JSON representation to the Haskell representation (or a Python typed
    representation) needs to know about the type hierarchy, otherwise document
    fragments are ambiguous **in the current JSON representation** (example ?
    even when it is not strictly ambiguous, the differentiation may be a mess).


JSON Representation of Documents
================================================================================

Playing with `Text.Pandoc.Types`
--------------------------------------------------------------------------------

Rk: display the full document model hierarchy in `ghci`:

    Prelude> :m + Text.Pandoc.Definition
    Prelude Text.Pandoc.Definition> :browse Text.Pandoc.Definition

yields almost EXACTLY the kind of terse type info I need (getting rid of the
constants and function maybe, cleanup of Map, then here we go !). Note that
the typeclass information is not present here, which is kind of nice for us.
Question: can I have ghci spit this representation to stdout and exit ?
Study <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html>

    data Alignment
      = AlignLeft | AlignRight | AlignCenter | AlignDefault
    type Attr = (String, [String], [(String, String)])
    data Block
      = Plain [Inline]
      | Para [Inline]
      | CodeBlock Attr String
      | RawBlock Format String
      | BlockQuote [Block]
      | OrderedList ListAttributes [[Block]]
      | BulletList [[Block]]
      | DefinitionList [([Inline], [[Block]])]
      | Header Int Attr [Inline]
      | HorizontalRule
      | Table [Inline] [Alignment] [Double] [TableCell] [[TableCell]]
      | Div Attr [Block]
      | Null
    data Citation
      = Citation {citationId :: String,
                  citationPrefix :: [Inline],
                  citationSuffix :: [Inline],
                  citationMode :: CitationMode,
                  citationNoteNum :: Int,
                  citationHash :: Int}
    data CitationMode = AuthorInText | SuppressAuthor | NormalCitation
    newtype Format = Format String
    data Inline
      = Str String
      | Emph [Inline]
      | Strong [Inline]
      | Strikeout [Inline]
      | Superscript [Inline]
      | Subscript [Inline]
      | SmallCaps [Inline]
      | Quoted QuoteType [Inline]
      | Cite [Citation] [Inline]
      | Code Attr String
      | Space
      | LineBreak
      | Math MathType String
      | RawInline Format String
      | Link [Inline] Target
      | Image [Inline] Target
      | Note [Block]
      | Span Attr [Inline]
    type ListAttributes = (Int, ListNumberStyle, ListNumberDelim)
    data ListNumberDelim = DefaultDelim | Period | OneParen | TwoParens
    data ListNumberStyle
      = DefaultStyle
      | Example
      | Decimal
      | LowerRoman
      | UpperRoman
      | LowerAlpha
      | UpperAlpha
    data MathType = DisplayMath | InlineMath
    newtype Meta
      = Meta {unMeta :: containers-0.5.0.0:Data.Map.Base.Map
                          String MetaValue}
    data MetaValue
      = MetaMap (containers-0.5.0.0:Data.Map.Base.Map String MetaValue)
      | MetaList [MetaValue]
      | MetaBool Bool
      | MetaString String
      | MetaInlines [Inline]
      | MetaBlocks [Block]
    data Pandoc = Pandoc Meta [Block]
    data QuoteType = SingleQuote | DoubleQuote
    type TableCell = [Block]
    type Target = (String, String)
    docAuthors :: Meta -> [[Inline]]
    docDate :: Meta -> [Inline]
    docTitle :: Meta -> [Inline]
    isNullMeta :: Meta -> Bool
    lookupMeta :: String -> Meta -> Maybe MetaValue
    nullAttr :: Attr
    nullMeta :: Meta



Helper to display the representation of a document fragment ?

Ref to the doc / source of the Haskell librray.

A word about AESON, the settings used in `Text.Pandoc.Types`, the results:
display examples of the different kind of serialisation used:

  - primitive types: Int, String, etc.

  - lists, maps,

  - algebraic data types

  - newtype stuff (ex: Format)

  - type Target = (String, String),

  - records: Meta, Citation



