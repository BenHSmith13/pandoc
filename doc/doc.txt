% Pandoc
% Sébastien Boisgérault
% January 13, 2016

  - What we intend to do: go beyond the JSON representation in Python,
    leverage a typed representation that is more natural ("Pythonic"),
    more familiar and convenient for Python developers. THIS is the
    primary goal of the Python module `pandoc`, not being a wrapper
    around the Haskell program.

  - Type-Aware Parsing, what it is why it is necessary: a translator from the
    JSON representation to the Haskell representation (or a Python typed
    representation) needs to know about the type hierarchy, otherwise document
    fragments are ambiguous **in the current JSON representation** (example ?
    even when it is not strictly ambiguous, the differentiation may be a mess).


The Pandoc Document Model
================================================================================

Structure of `Text.Pandoc.Types`
--------------------------------------------------------------------------------

Rk: display the full document model hierarchy in `ghci`:

    Prelude> :m + Text.Pandoc.Definition
    Prelude Text.Pandoc.Definition> :browse Text.Pandoc.Definition

yields almost EXACTLY the kind of terse type info I need (getting rid of the
constants and function maybe, cleanup of Map, then here we go !). Note that
the typeclass information is not present here, which is kind of nice for us.
Question: can I have ghci spit this representation to stdout and exit ?
Study <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html>

    data Alignment
      = AlignLeft | AlignRight | AlignCenter | AlignDefault
    type Attr = (String, [String], [(String, String)])
    data Block
      = Plain [Inline]
      | Para [Inline]
      | CodeBlock Attr String
      | RawBlock Format String
      | BlockQuote [Block]
      | OrderedList ListAttributes [[Block]]
      | BulletList [[Block]]
      | DefinitionList [([Inline], [[Block]])]
      | Header Int Attr [Inline]
      | HorizontalRule
      | Table [Inline] [Alignment] [Double] [TableCell] [[TableCell]]
      | Div Attr [Block]
      | Null
    data Citation
      = Citation {citationId :: String,
                  citationPrefix :: [Inline],
                  citationSuffix :: [Inline],
                  citationMode :: CitationMode,
                  citationNoteNum :: Int,
                  citationHash :: Int}
    data CitationMode = AuthorInText | SuppressAuthor | NormalCitation
    newtype Format = Format String
    data Inline
      = Str String
      | Emph [Inline]
      | Strong [Inline]
      | Strikeout [Inline]
      | Superscript [Inline]
      | Subscript [Inline]
      | SmallCaps [Inline]
      | Quoted QuoteType [Inline]
      | Cite [Citation] [Inline]
      | Code Attr String
      | Space
      | LineBreak
      | Math MathType String
      | RawInline Format String
      | Link [Inline] Target
      | Image [Inline] Target
      | Note [Block]
      | Span Attr [Inline]
    type ListAttributes = (Int, ListNumberStyle, ListNumberDelim)
    data ListNumberDelim = DefaultDelim | Period | OneParen | TwoParens
    data ListNumberStyle
      = DefaultStyle
      | Example
      | Decimal
      | LowerRoman
      | UpperRoman
      | LowerAlpha
      | UpperAlpha
    data MathType = DisplayMath | InlineMath
    newtype Meta
      = Meta {unMeta :: containers-0.5.0.0:Data.Map.Base.Map
                          String MetaValue}
    data MetaValue
      = MetaMap (containers-0.5.0.0:Data.Map.Base.Map String MetaValue)
      | MetaList [MetaValue]
      | MetaBool Bool
      | MetaString String
      | MetaInlines [Inline]
      | MetaBlocks [Block]
    data Pandoc = Pandoc Meta [Block]
    data QuoteType = SingleQuote | DoubleQuote
    type TableCell = [Block]
    type Target = (String, String)
    docAuthors :: Meta -> [[Inline]]
    docDate :: Meta -> [Inline]
    docTitle :: Meta -> [Inline]
    isNullMeta :: Meta -> Bool
    lookupMeta :: String -> Meta -> Maybe MetaValue
    nullAttr :: Attr
    nullMeta :: Meta





Pythonize this info
--------------------------------------------------------------------------------

  - copy-and-paste the type definition info from ghci into `_types.hs`.

  - invoke 

        $ pandoc/types/defs/main.py _types.hs > _types.py

  - `types.py` now contains a Python description of the type structure,
    into a `defs` global variable.

Hence 

  - `pandoc.types.def` contains info about the Pandoc DOM structure, 
    in a raw form

  - `pandoc.types` declares the Python classes from this structure:
    explain this stuff in the next section ...


Pandoc.Types
--------------------------------------------------------------------------------

Every Haskell data type corresponds to one Python data type defined in
`pandoc.types`. It is either a primitive, a type (for the lack of a better
world), a singleton or a typedef. Every such class is available as a symbol
of the `pandoc.types` module and as a key of the `primitives`, `types`,
`singletons` or `typedefs` dictionary.

  - Primitives are matched directly to Python native types: 
    `String` corresponds to `unicode`, `Bool` to `bool`, etc.

  - Types correspond the Haskell data types declared with the `data` or `newtype` 
    keywords

  - Typedefs are type aliases (or synonyms), introduced in Haskell with the
    `type` keyword.

Source: <https://wiki.haskell.org/Type>

JSON Serialization
================================================================================

Need to document/understand how ALL constructs of the Pandoc document model
are serialized. A small helper to display the representation of a document 
fragment would be nice ...

Ref to the doc / source of the Haskell librray.

A word about AESON, the settings used in `Text.Pandoc.Types`, the results:
display examples of the different kind of serialisation used:

  - primitive types: Int, String, etc.

  - lists, maps,

  - algebraic data types

  - newtype stuff (ex: Format)

  - type Target = (String, String),

  - records: Meta, Citation

-----

newtype: Meta, Format, records: Meta, Citation.

examples:

    Meta -> {"unMeta": metadata_map}

No indication in the json of the Meta type, and not a list of arguments but a
map indexed by the (here unique) fields.

    Format -> "html"

The type info has been stripped, and the content directly exposed. Mmmm,
the content is not even in a list ? How would have been exposed a newtype
wrapper with multiple args ? OK, it CANNOT happen, by construction, 
newtypes have a single field.

    Citation -> {"citationSuffix":...,
                 "citationNoteNum":...,
                 "citationMode":...,
                 "citationPrefix":...,
                 "citationId":...,
                 "citationHash":...}

So basically, records are serialized as dictionaries and their type info is
stripped; newtypes are also stripped type info. That's all there is.

-----

Need to explain of a "JSON parsing" driven by a type hierarchy can work.

THIS is meant to be implemented at the top-level, in `pandoc` main 
(`load` function; a script would also be nice to test this stuff from 
the command-line).


