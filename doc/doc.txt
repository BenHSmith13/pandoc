% The Pandoc Document Model
% Sébastien Boisgérault
% January 13, 2016

Goals / the take-away:

  - If you intend to parse the JSON output from pandoc -- outside of Haskell, 
    say in Javascript, Python, etc. -- 
    you will thank me.

  - If you want to use the current tools to do stuff with pandoc documents
    in dynamic languages (yeah, I am looking at you `pandoc-filters`),
    think again.

  - High-level: prepare for a Python lib to instantiate, analyze, transform, etc.
    documents that are instance of the Pandoc Document Model into Pythonic type. 
    Prerequisite:understand this model (Doh'!) which means a bit of Haskell 
    typing, and understand how these instances are mapped to the generic JSON
    model.

  - Help you understand the doc (in Haskell) of Pandoc Types, to understand
    the Pandoc "Document Model". To this, we need to learn a bit about the
    Haskell types.

  - Understand how AESON converts such Haskell objects into JSON.

  - Understand how you can (or cannot) use the JSON output in your favorite
    langage (on the limitation side, make pandoc-filters fail?)

  - See that parsing this is difficult, UNLESS YOU HAVE A REPRESENTATION OF
    THE PANDOC TYPE HIERARCHY IN THE PARSER.

  - Type-Aware Parsing, what it is why it is necessary: a translator from the
    JSON representation to the Haskell representation (or a Python typed
    representation) needs to know about the type hierarchy, otherwise document
    fragments are ambiguous **in the current JSON representation** (example?
    even when it is not strictly ambiguous, the differentiation may be a mess).

  - Understand the JSON representation of Pandoc document: for this, you need
    to understand a bit of the Haskell type system and how AESON deals with it.

TODO:


  - LONG-TERM: What we intend to do: go beyond the JSON representation in Python,
    leverage a typed representation that is more natural ("Pythonic"),
    more familiar and convenient for Python developers. THIS is the
    primary goal of the Python module `pandoc`, not being a wrapper
    around the Haskell program. --> GET THIS COMMENT OUT OF THIS DOC.

  - replicate the steps to be able to test some serialization in Pandoc.
    From the command-line or ghci?

  - explain the Haskell constructs of the type hierarchy so that
    the users can understand the Haskell doc.

  - explain JSON serialization of each construct.

  - extra limitation when we have not the type hierarchy even with primitive
    types: tuples are serialized as lists.


Preamble -- The Haskell Interactive Environment
================================================================================

I actually find easier to explore the pandoc document model from the Haskell
interactive environment than from the command line -- 
even though I am not really familiar with Haskell. 
This approach doesn't require pandoc the command-line tool, but the associated 
Haskell packages; they may not be available if you have only performed a
basic install of pandoc.

Make sure that the Haskell interactive environement [GHCi] and all Haskell 
packages associated to pandoc are installed. On Ubuntu for example,
you may execute the command 

    $ sudo apt-get install libghc-pandoc.*

and then start GHCi with 

    $ ghci

In this document, we denote commands executed in GHCi with the `>` prefix; 
that's a behavior that you can reproduce if you type 

    :set prompt "> "

once you have started GHCi.

[GHCi]: https://wiki.haskell.org/GHC/GHCi


Pandoc Types
================================================================================

As of today, the best way to understand the details of the pandoc document model
is to refer to the documentation of the `pandoc-types` Haskell package, 
more precisely of its `Text.Pandoc.Definition` module.
This module contains the definition of all pandoc types used to describe
any Pandoc document; you may search for `pandoc-types` on the [Hackage] 
package archive to read the latest version of the documentation 
(1.16 at the moment).

[Hackage]: http://hackage.haskell.org

The bad news I guess is that you have to understand the basic of Haskell types
to understand the document model; on the flip side, this documentation is
very precise and quite simple once you understand the basic constructs.

We are going to explain the basics of Haskell data types directly on
the types provided with Pandoc; more details may be found on the
[Haskell Wiki](https://wiki.haskell.org/Type).

We can get all the information wen need about pandoc types we need from GHCi. 
First, load the `Text.Pandoc.Definition` module

    > import Text.Pandoc.Definition

Then, say that you are interested in the definition of the type `Pandoc` 
that is associated to whole documents; type:

    > :info Pandoc
    data Pandoc = Pandoc Meta [Block]
    ...

(the ellipsis denotes details of the output that we have omitted).
The first line of the output specifies that the type `Pandoc` (keyword`data`) 
is declared with a single constructor (in the right-hand side), named `Pandoc`, 
whose arguments are an instance of `Meta` -- the document metadata -- 
and a list of `Block` instances -- that compose the document itself.

This is the enough information to build an instance of document: 
`Text.Pandoc.Definition` already provides an empty metadata with `nullMeta`,
so we may use this

    > let meta = nullMeta
    > meta
    Meta {unMeta = fromList []}

(don't freak out, we are going to explain this weird output syntax in a moment)
and for blocks, the easiest thing to do is to use an empty list:

    > let blocks = []
    > blocks
    []

Now, we may assemble these arguments to create an (empty) document:

    > let doc = Pandoc meta blocks
    > doc
    Pandoc (Meta {unMeta = fromList []}) []

You may repeat this approach with the types that used to define `Pandoc`
instances. For example, if you want to know more about the contents of blocks, 
type:

    > :info Block
    data Block
      = Plain [Inline]
      | Para [Inline]
      | CodeBlock Attr String
      | RawBlock Format String
      | BlockQuote [Block]
      | OrderedList ListAttributes [[Block]]
      | BulletList [[Block]]
      | DefinitionList [([Inline], [[Block]])]
      | Header Int Attr [Inline]
      | HorizontalRule
      | Table [Inline] [Alignment] [Double] [TableCell] [[TableCell]]
      | Div Attr [Block]
      | Null
    ...

The `Block` type has 13 different constructors. 
Some of the constructors have no arguments, for example the horizontal rule

    > let block = HorizontalRule

but most of them have arguments of various types. 
`Attr`, `Format`, `ListAttributes`, etc. are types defined by pandoc,
but `String` and `Int` are Haskell primitive types. The notation `[]` refers to 
lists and `()` refers to tuples, so `[[Block]]` is for example a list of list 
of blocks and `[([Inline], [[Block]])]` is a list of pairs of list of inlines 
and list of list of blocks (ouch !).

Some of the pandoc types are not really new constructs but only aliases used
to provide a shorter notation. For example, `Attr` is one of such types,
defined with the `type` keyword:

    > :info Attr
    type Attr = (String, [String], [(String, String)])

Hence we may define a code block with

    > let attr = ("", [], [])
    > let block = CodeBlock attr "content"

The declaration of the `Format` type doesn't use the `data` keyword either, 
but instead the `newtype` keyword

    > :info Format
    newtype Format = Format String
    ...

You can think of it as an optimization of the `data` construct when 
the type has a simple constructor whose name is the type name, so the
instantiation is business as usual:

    > let format = Format "html"

The final construct that we need to explain is the record. Consider for
example the `Meta` type:

    > :info Meta
    newtype Meta
      = Meta {unMeta :: Data.Base.Map String MetaValue}

Its only constructor is declared as a record -- with the `{}` syntax -- 
that has a single field named `unMeta`. As a consequence, it can be 
instantiated with named arguments instead of positional argument:

    > import Data.Map (empty, fromList, Map)
    > let meta = Meta {unMeta = empty}
    > meta
    Meta {unMeta = fromList []}

An extra feature of this declaration: a function `unMeta` has been automatically
defined to get the content of the `unMeta` field from the instance of `Meta`:
    
    > unMeta meta
    fromList []

Note however that records keep the behavior of classic constructors and that
`meta` could have been defined with the positional argument syntax:

    > let meta = Meta (empty)
    > meta
    Meta {unMeta = fromList []}

The only other record used by pandoc types is `Citation`:

    > :info Citation
    data Citation
      = Citation {citationId :: String,
                  citationPrefix :: [Inline],
                  citationSuffix :: [Inline],
                  citationMode :: CitationMode,
                  citationNoteNum :: Int,
                  citationHash :: Int}
    ...

After `Pandoc`, `Block` and `Meta`, it's a good idea to have a look
at the `Inline` pandoc type, the last major component of the document model.

    > :info Inline
    data Inline
      = Str String
      | Emph [Inline]
      | Strong [Inline]
      | Strikeout [Inline]
      | Superscript [Inline]
      | Subscript [Inline]
      | SmallCaps [Inline]
      | Quoted QuoteType [Inline]
      | Cite [Citation] [Inline]
      | Code Attr String
      | Space
      | LineBreak
      | Math MathType String
      | RawInline Format String
      | Link [Inline] Target
      | Image [Inline] Target
      | Note [Block]
      | Span Attr [Inline]
    ...

There is no new Haskell type construct here, everything should be clear.

JSON Representation
================================================================================

### The Basics

Pandoc leverages the [aeson] package to serialize pandoc type instances as JSON
strings.
With three lines of Haskell we may define a function `js` that displays the JSON
representation of any pandoc construct:

[aeson]: https://hackage.haskell.org/package/aeson

    > import Data.Aeson (encode, ToJSON)
    > import qualified Data.ByteString.Lazy.Char8 as BS
    > let js :: (ToJSON a) => a -> IO (); js = BS.putStrLn . encode

Let's start with the most basic types to see how this works. 
First, consider the primitive types used in the document model, 
that is booleans, integers and strings:

    > js True
    true
    > js 42
    42
    > js "text"
    "text"

Nothing to surprising here. Now, consider the standard containers used in 
Haskell: lists, tuples and maps.

    > js ["a", "b", "c"]
    ["a","b","c"]

    > let map = fromList [("a", 1), ("b", 2)]
    > js map
    {"a":1,"b":2}

    > js (True, 1, "text")
    [true,42,"text"]

Haskell lists are mapped to javascript lists, maps to javascript objects,
but tuples, that have no equivalent in javascript, are also mapped to lists.
Is this ambiguity an issue if we want to recreate the original tuple from 
its JSON representation ? Well, it depends if you still know that the original
data was a tuple ... we will study this subject in greater generality 
in detail later. 

Note that the rules to serialize a datum are applied
recursively to the contents of containers -- and that property holds for
standard Haskell types as well as all pandoc types. So we have for example:

    > js ("a", ["b"], [("c", "d")])
    ["a",["b"],[["c","d"]]]

Let's have a look at pandoc types now. Consider `MathType` ;
both its constructors take no argument:

    > :info MathType
    data MathType = DisplayMath | InlineMath

Such data is serialized as a

    > js InlineMath
    {"t":"InlineMath","c":[]}

Basically: a javascript object where the constructor name is associated with the 
`"t"` key (think of "tag" or "type constructor") and the list of constructor 
arguments (here empty) is associated to the `"c"` key (think of "contents")

Yes, again, this is potentially ambiguous: how do you know that the JSON string
refers to an instance of `InlineMath` and not a Haskell map ?



The same rules apply when we consider constructors with arguments. 
For example, consider the `MathType` constructor associated to 
the `Inline` data type:

    > :info Math
    data Inline = ... | Math MathType String | ...

Its instances are serialized as follows:

    > js (Math InlineMath "a=1")
    {"t":"Math","c":[{"t":"InlineMath","c":[]},"a=1"]}


### Special Cases

... context ... explain this stuff as "optimizations" (json output length).

#### Single Argument

Consider for example

    > :info Str
    data Inline = Str String | ...

Obviously, `js (Str "text")` should be serialized as `{"t":"Str","c":["text"]}`,
right ? Think again:

    > js (Str "text")
    {"t":"Str","c":"text"}

When constructors have a single argument, the list associated to the "c" key
is unwrapped. This can get slightly tricky: only one level of list is removed.
For example, for the emphasis

    > :info Emph
    data Inline = ... | Emph [Inline] | ...

we have

    > js (Emph [Str "text"])
    {"t":"Emph","c":[{"t":"Str","c":"text"}]}

instead of `{"t":"Emph","c":[[{"t":"Str","c":"text"}]]}`.

Records have there own serialization scheme. Consider for example

    > :info Citation
    data Citation
      = Citation {citationId :: String,
                  citationPrefix :: [Inline],
                  citationSuffix :: [Inline],
                  citationMode :: CitationMode,
                  citationNoteNum :: Int,
                  citationHash :: Int}

The principle is simple: instead of the `"c"` key in the javascript object,
a key-value pair is added for every record field:

    > js (Citation "" [] [] NormalCitation 0 0)
    {"t":"Citation","citationSuffix":[],"citationNoteNum":0,"citationMode":
    {"t":"NormalCitation","c":[]},"citationPrefix":[],"citationId":"",
    "citationHash":0}

Actually this is not *exactly* what happens because citations fall into the
scope of the type erasure special case explained in the next section. I would
happily show you an example of a pandoc record that is handled according to
the general principle ... but the only other one is `Meta` and it's also a 
special case!


### Single Constructor 

Consider the JSON representation of an instance of type that has a single
constructor: if you know the type of the data, the type constructor 
information associated to the "t" key is redundant, hence pandoc gets
rid of it of the unused structures.

For example, consider

    > :info Meta
    newtype Meta
      = Meta {unMeta :: Map String MetaValue}
    ...

The generic serialization of `nullMeta` should be `{"t":Meta,"unMeta":{}}`.
But if you know that you deal with an instance of `Meta`, given that there
is a single constructor (also called `Meta`) for this type, pandoc does
not need the type constructor info to reconstruct the data, hence, it does
not include it, and you have instead:

    > js nullMeta
    {"unMeta":{}}

Similarly, consider the `Format` type:

    > :info Format
    newtype Format = Format String
    ...

For `Format "html"`, instead of `{"t":"Format","c":"html"}`, we can get
rid of the `"t"` key and the whole JS object becomes unnecessary, only 
the value of the "c" key is kept:

    > js (Format "html")
    "html"

### Ambiguities

Philosophy: what should be in the JSON, static vs dynamic languages.

Makes sense for Haskell-to-Haskell serialization.

Blame it on aeson.

  - tuples vs lists

  - maps

  - single argument

  - single constructor

Abuse each one of them ? Can't probably. Find at least on exploit to 
fuck pandoc-filters.


-----

How I learned to hate AESON: JSON exports that is supposed to
be helpful but is not really unless u have kept the type hierarchy (or:
"premature optimization"): stripped types and single-argument unwrapping
optimization and tuples are lists and maps may be maps or pandoc types.
List these ambiguities, and exploit them somehow.

TODO: fuck pandoc-filters, JSON is not usable unless you also pull the
types definition info. Either the output format contains all there is
to know about the data AND the type info, or you need to get the type
info into your parser ...

\newpage

Appendix -- Pandoc Types Definition
================================================================================

To display the complete list of pandoc types definition, type in GHCi:

    > import Data.Map (Map)
    > import Text.Pandoc.Definition
    > :browse

The output of this command sequence, slightly reformated to enhance readability:

    data Alignment
      = AlignLeft 
      | AlignRight 
      | AlignCenter 
      | AlignDefault

    type Attr 
      = (String, [String], [(String, String)])

    data Block
      = Plain [Inline]
      | Para [Inline]
      | CodeBlock Attr String
      | RawBlock Format String
      | BlockQuote [Block]
      | OrderedList ListAttributes [[Block]]
      | BulletList [[Block]]
      | DefinitionList [([Inline], [[Block]])]
      | Header Int Attr [Inline]
      | HorizontalRule
      | Table [Inline] [Alignment] [Double] [TableCell] [[TableCell]]
      | Div Attr [Block]
      | Null

    data Citation
      = Citation {citationId :: String,
                  citationPrefix :: [Inline],
                  citationSuffix :: [Inline],
                  citationMode :: CitationMode,
                  citationNoteNum :: Int,
                  citationHash :: Int}

    data CitationMode 
      = AuthorInText 
      | SuppressAuthor 
      | NormalCitation

    newtype Format 
      = Format String

    data Inline
      = Str String
      | Emph [Inline]
      | Strong [Inline]
      | Strikeout [Inline]
      | Superscript [Inline]
      | Subscript [Inline]
      | SmallCaps [Inline]
      | Quoted QuoteType [Inline]
      | Cite [Citation] [Inline]
      | Code Attr String
      | Space
      | LineBreak
      | Math MathType String
      | RawInline Format String
      | Link [Inline] Target
      | Image [Inline] Target
      | Note [Block]
      | Span Attr [Inline]

    type ListAttributes 
      = (Int, ListNumberStyle, ListNumberDelim)

    data ListNumberDelim 
      = DefaultDelim 
      | Period 
      | OneParen 
      | TwoParens

    data ListNumberStyle
      = DefaultStyle
      | Example
      | Decimal
      | LowerRoman
      | UpperRoman
      | LowerAlpha
      | UpperAlpha

    data MathType
      = DisplayMath 
      | InlineMath

    newtype Meta
      = Meta {unMeta :: Map String MetaValue}

    data MetaValue
      = MetaMap (Map String MetaValue)
      | MetaList [MetaValue]
      | MetaBool Bool
      | MetaString String
      | MetaInlines [Inline]
      | MetaBlocks [Block]

    data Pandoc 
      = Pandoc Meta [Block]

    data QuoteType 
      = SingleQuote 
      | DoubleQuote

    type TableCell 
      = [Block]

    type Target 
      = (String, String)

    ...

Function declarations have been omitted.



